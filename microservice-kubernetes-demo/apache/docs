<!-- https://github.com/ewolff/microservice-kubernetes.git


cd microservice-kubernetes/
kubectl apply -f microservice-kubernetes-demo/microservices.yaml -->

// CREATE LOAD BALANCER
lb = make_unique<LoadBalancer>(80, 8081);

// CONFIGURE PATH-BASED ROUTING WITH DIFFERENT STRATEGIES

// Customer Service - IP Hash (Sticky Sessions)
lb->addService("/customer/", LoadBalancingAlgorithm::IP_HASH);
lb->addBackendToService("/customer/", "customer-1", "customer", 8080, 3, 30);

// Catalog Service - Least Connections (Optimal Load Distribution)
lb->addService("/catalog/", LoadBalancingAlgorithm::LEAST_CONNECTIONS);
lb->addBackendToService("/catalog/", "catalog-1", "catalog", 8080, 3, 30);

// Order Service - Round Robin (Simple Rotation)
lb->addService("/order/", LoadBalancingAlgorithm::ROUND_ROBIN);
lb->addBackendToService("/order/", "order-1", "order", 8080, 3, 30);

shared_ptr<ServiceConfig> LoadBalancer::matchService(const string& path) {
    // Find longest matching prefix
    shared_ptr<ServiceConfig> matched = nullptr;
    size_t maxLen = 0;
    
    // Loop through all configured services
    for (auto& [servicePath, config] : services) {
        // Check if request path starts with service path
        if (path.find(servicePath) == 0 && servicePath.length() > maxLen) {
            matched = config;  // Match found!
            maxLen = servicePath.length();  // Track longest match
        }
    }
    
    return matched;
}

bool Backend::checkHealth() {
    // Create TCP socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    
    // Set 2-second timeout
    struct timeval tv;
    tv.tv_sec = 2;
    tv.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    
    // Resolve backend hostname and connect
    struct hostent* server = gethostbyname(host.c_str());
    struct sockaddr_in serverAddr;
    serverAddr.sin_port = htons(port);
    
    // Attempt connection
    int result = connect(sock, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
    close(sock);
    
    return result == 0;  // Success if connection established
}

# Credentials stored in ConfigMaps
postgres-config:
  POSTGRES_DB: microservicesdb
  POSTGRES_USER: admin
  POSTGRES_PASSWORD: admin123

mongodb-config:
  MONGO_INITDB_DATABASE: microservicesdb
  MONGO_INITDB_ROOT_USERNAME: admin
  MONGO_INITDB_ROOT_PASSWORD: admin123

spring.datasource.url=jdbc:postgresql://postgres:5432/microservicesdb
spring.datasource.username=admin
spring.datasource.password=admin123
spring.jpa.hibernate.ddl-auto=update

spring.data.mongodb.host=mongodb
spring.data.mongodb.port=27017
spring.data.mongodb.database=microservicesdb
spring.data.mongodb.username=admin
spring.data.mongodb.password=admin123

spring.datasource.url=jdbc:postgresql://postgres:5432/ordersdb
# Same connection mechanism as Catalog service
# Uses separate database: ordersdb

1. User clicks "Add Item" on web form
   POST https://microservices.local:8443/catalog/

2. Ingress → C++ Load Balancer → Catalog Service

3. Catalog Service (Java/Spring Boot):
   @PostMapping("/")
   public String addItem(@ModelAttribute Item item) {
       itemRepository.save(item);  // JPA handles SQL
   }

4. JPA/Hibernate generates SQL:
   INSERT INTO item (name, price) VALUES ('Laptop', 55000);

5. PostgreSQL executes query:
   - Auto-generates ID (using SERIAL sequence)
   - Returns new item with ID

6. Response sent back: Item created with ID 9

1. User clicks "Delete" button
   POST https://microservices.local:8443/catalog/9?_method=DELETE

2. Catalog Service:
   @DeleteMapping("/{id}")
   public String deleteItem(@PathVariable Long id) {
       itemRepository.deleteById(id);
   }

3. Hibernate generates SQL:
   DELETE FROM item WHERE id=9;

4. PostgreSQL removes the row

5. ID sequence continues (next item will be ID 10)
   - Deleted IDs are NOT reused

minio.url=http://minio:9000
minio.access-key=minioadmin
minio.secret-key=minioadmin
minio.bucket-name=catalog-images

These are examples of PromQL queries that can be used in Grafana dashboards:CPU Usage per Pod
process_cpu_usage{job="kubernetes-pods"} * 100
Memory Usage per Service (in MB)
sum(jvm_memory_used_bytes{area="heap"}) by (kubernetes_pod_name) / 1024 / 1024
HTTP Request Rate (per minute)
sum(rate(http_server_requests_seconds_count[1m])) by (uri)
✅ Outcome
